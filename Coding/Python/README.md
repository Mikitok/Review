**Q：谈下python的GIL**

1. GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
2. 多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大

**Q：fun(\*args,\*\*kwargs)中的\*args,\*\*kwargs什么意思？**

\*args、\*\*kwargs是python中的可变参数。\*args表示任何多个无名参数，它是一个tuple；\*\*kwargs表示关键字参数，它是一个dict。并且同时使用\*args和\*\*kwargs时，必须\*args参数列要在\*\*kwargs前。

**Q：python中内置的数据结构有几种？**
整型 int、浮点型 float、字符串 str、列表 list、元组 tuple、字典 dict 集合 set

**Q：Python 中的__new__和__init__的区别**

1. __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
2. __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。
3.  __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。

**Q：python2和python3区别？列举5个**

1. Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')。Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'
2. python2 range(1,10)返回列表，python3中返回迭代器，节约内存
3. python2中使用ascii编码，python中使用utf-8编码
4. python2中unicode表示字符串序列，str表示字节序列，python3中str表示字符串序列，byte表示字节序列
5. python2中为正常显示中文，引入coding声明，python3中不需要
6. python2中是raw_input()函数，python3中是input()函数 

**Q：列出python中可变数据类型和不可变数据类型，并简述原理**

1. 不可变数据类型：数值型、字符串型string和元组tuple。不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）。
2. 可变数据类型：列表list、字典dict和集合set。其中的元素可以动态的增加或删除。

**Q：介绍一下lambda**

lambda 定义了一个匿名函数，lambda 并不会带来程序运行效率的提高，只会使代码更简洁。所以复杂的函数不适合lambda。

**Q：用python删除文件和用linux命令删除文件方法**

1. python：os.remove(文件名)
2. linux：rm  文件名

**Q：说明异常模块中的try except else finally的意义**

1. try里写不确定是否能够正常执行的代码
2. except捕获异常，并进行对应操作
3. else如果没有异常，就执行以下的代码。
4. finally不管是否有异常都执行

**Q：简述any()和all()方法**

1. any():只要迭代器中有一个元素为真就为真
2. all():迭代器中所有的判断项返回都是真，结果才为真

**Q：python深拷贝和浅拷贝的区别**

1. 深拷贝和浅拷贝都是对象的拷贝，他们本质的区别是拷贝出来的对象的地址是否和原对象一样。
2. 对于不可变数据类型，拷贝之后的id都和原来一样。
3. 对于可变对象，拷贝之后的id都和原来不同。深拷贝完全复制独立。对于浅拷贝，如果复制的对象中无复杂子对象，原来值和浅复制的值之间的改变不会互相影响；如果复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表），改变原来的值中的复杂子对象的值，会影响浅复制的值。

**Q：介绍一下python中的垃圾回收机制**

1. 垃圾回收目的是找到内存中无用的垃圾资源，清除这些垃圾并把内存让出来给其他对象使用。python垃圾回收机制是以引用计数为主，标记-清除和分代回收为辅，其中标记-清除和分代回收主要是为了处理循环引用的难题。
2. 引用计数就是每个对象维护一个引用次数的字段，计数为0，该对象立即被回收。它的缺点是需要额外计数空间，且无法处理循环引用的问题。
3. 标记-清除分为两个阶段：标记和回收。对象之间通过引用（指针）连在一起，构成一个有向图。从根对象出发，沿着有向边遍历对象，可达的对象标记为活动对象，不可达的对象就是要被清除的非活动对象。然后清除不可达对象。缺点是每次必须扫面整个堆内存。
4. 分代回收是一种以空间换时间的操作方式，将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。通过对不同的代设置不同的阈值，可以在不同的时间间隔处理这些对象。

**Q：python为什么慢？**

1. python有一个全局解释器锁。现代计算机搭载拥有多个内核的CPU，一个进程可以分为多个线程并行计算。但是对于python来说，由于GIL锁的存在，限制一次只有一个线程使用python解释器，其他线程要等该线程运行完后其他线程才能运行。所以对于CPU 密集型的任务，Python 的多线程效率提升空间较小。
2. python是一个解释型的语言。像C/C++这些语言直接编译成机器码运行，而Python 的运行过程是虚拟机读入代码，编译成中间代码，解释器再将中间代码翻译成 CPU 可以理解的指令，相比于直接编译成机器码，肯定是慢的。
3. python的变量是动态类型，检查类型和改变类型开销太大。

**Q：函数装饰器有什么作用？**

装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能。装饰器的返回值也是一个函数的对象，他的使用场景比如：插入日志，计时等。有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。 

**Q：Python中类方法、实例方法、静态方法区别**
1. 实例方法只能由实例对象调用，第一个参数必须是实例对象，该参数名一般约定为“self”。
2. 类方法实例对象和类对象都可以调用，使用装饰器@classmethod。第一个参数必须是当前类对象，该参数名一般约定为“cls”。
3. 静态方法实例对象和类对象都可以调用，使用装饰器@staticmethod，方法体中不能使用类或实例的任何属性和方法，静态方法实际上跟该类没有太大关系。

**Q：迭代器和生成器区别**
1. 迭代器可以通过序列内置的iter()函数创建，要获取下一个元素，可以使用next()。当没有元素时候，会产生异常，结束循环。
2. 生成器是一种特殊的迭代器，是通过通过yield语句快速生成迭代器。

**Q：内存泄露是什么？如何避免？**

内存泄露指的是由于疏忽，或者错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制，因而造成了内存的浪费。避免的方法如下：
1. 编写安全的代码。内存泄漏很大的一个原因是自定义了__del__方法，所以可能造成循环引用。所以如果自定义__del__方法，要在释放前释放引用。
2. 通过 Python 扩展模块 gc 来查看不能回收的对象的详细信息。
3. 获取对象的引用计数，并根据返回值是否为 0 来判断是否内存泄漏。

**Q：解释一下python中的闭包**

# References
1. [python110道面试题](https://www.cnblogs.com/lmx123/p/9230589.html)
2. [Python: 什么是\*args和\*\*kwargs](https://www.cnblogs.com/yx12138/p/10742766.html)
3. [Python 中的__new__和__init__的区别](https://www.cnblogs.com/shenxiaolin/p/9307496.html)
4. [Python中的垃圾回收机制](https://foofish.net/python-gc.html)
5. [Python 为什么这么慢？](https://blog.csdn.net/chinesehuazhou2/article/details/90746215)
6. [python中类方法，实例方法，静态方法的作用和区别](https://www.cnblogs.com/geogre123/p/10142510.html)
7. [Python迭代器](https://www.cnblogs.com/louyefeng/p/9430415.html)
