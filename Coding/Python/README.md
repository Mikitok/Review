**Q：谈下python的GIL**
1. GIL 是python的全局解释器锁，同一进程中假如有多个线程运行，一个线程在运行python程序的时候会霸占python解释器（加了一把锁即GIL），使该进程内的其他线程无法运行，等该线程运行完后其他线程才能运行。如果线程运行过程中遇到耗时操作，则解释器锁解开，使其他线程运行。所以在多线程中，线程的运行仍是有先后顺序的，并不是同时进行。
2. 多进程中因为每个进程都能被系统分配资源，相当于每个进程有了一个python解释器，所以多进程可以实现多个进程的同时运行，缺点是进程系统资源开销大

**Q：fun(\*args,\*\*kwargs)中的\*args,\*\*kwargs什么意思？**
\*args、\*\*kwargs是python中的可变参数。\*args表示任何多个无名参数，它是一个tuple；\*\*kwargs表示关键字参数，它是一个dict。并且同时使用\*args和\*\*kwargs时，必须\*args参数列要在\*\*kwargs前。

**Q：python中内置的数据结构有几种？**
整型 int、浮点型 float、字符串 str、列表 list、元组 tuple、字典 dict 集合 set

**Q：Python 中的__new__和__init__的区别**
1. __new__是在实例创建之前被调用的，因为它的任务就是创建实例然后返回该实例对象，是个静态方法。
2. __init__是当实例对象创建完成后被调用的，然后设置对象属性的一些初始值，通常用在初始化一个类实例的时候。是一个实例方法。
3.  __new__先被调用，__init__后被调用，__new__的返回值（实例）将传递给__init__方法的第一个参数，然后__init__给这个实例设置一些参数。

**Q：python2和python3区别？列举5个**
1. Python3 使用 print 必须要以小括号包裹打印内容，比如 print('hi')。Python2 既可以使用带小括号的方式，也可以使用一个空格来分隔打印内容，比如 print 'hi'
2. python2 range(1,10)返回列表，python3中返回迭代器，节约内存
3. python2中使用ascii编码，python中使用utf-8编码
4. python2中unicode表示字符串序列，str表示字节序列，python3中str表示字符串序列，byte表示字节序列
5. python2中为正常显示中文，引入coding声明，python3中不需要
6. python2中是raw_input()函数，python3中是input()函数 

**Q：列出python中可变数据类型和不可变数据类型，并简述原理**
1. 不可变数据类型：数值型、字符串型string和元组tuple。不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址）。
2. 可变数据类型：列表list、字典dict和集合set。其中的元素可以动态的增加或删除。

**Q：介绍一下lambda**
lambda 定义了一个匿名函数，lambda 并不会带来程序运行效率的提高，只会使代码更简洁。所以复杂的函数不适合lambda。

**Q：用python删除文件和用linux命令删除文件方法**
1. python：os.remove(文件名)
2. linux：rm  文件名

**Q：说明异常模块中的try except else finally的意义**
1. try里写不确定是否能够正常执行的代码
2. except捕获异常，并进行对应操作
3. else如果没有异常，就执行以下的代码。
4. finally不管是否有异常都执行

**Q：简述any()和all()方法**
1. any():只要迭代器中有一个元素为真就为真
2. all():迭代器中所有的判断项返回都是真，结果才为真

**Q：python深拷贝和浅拷贝的区别**
1. 深拷贝和浅拷贝都是对象的拷贝，他们本质的区别是拷贝出来的对象的地址是否和原对象一样。
2. 对于不可变数据类型，拷贝之后的id都和原来一样。
3. 对于可变对象，拷贝之后的id都和原来不同。深拷贝完全复制独立。对于浅拷贝，如果复制的对象中无复杂子对象，原来值和浅复制的值之间的改变不会互相影响；如果复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表），改变原来的值中的复杂子对象的值，会影响浅复制的值。

**Q：介绍一下python中的垃圾回收机制**
1. 垃圾回收目的是找到内存中无用的垃圾资源，清除这些垃圾并把内存让出来给其他对象使用。python垃圾回收机制是以引用计数为主，标记-清除和分代回收为辅，其中标记-清除和分代回收主要是为了处理循环引用的难题。
2. 引用计数就是每个对象维护一个引用次数的字段，计数为0，该对象立即被回收。它的缺点是需要额外计数空间，且无法处理循环引用的问题。
3. 标记-清除分为两个阶段：标记和回收。对象之间通过引用（指针）连在一起，构成一个有向图。从根对象出发，沿着有向边遍历对象，可达的对象标记为活动对象，不可达的对象就是要被清除的非活动对象。然后清除不可达对象。缺点是每次必须扫面整个堆内存。
4. 分代回收是一种以空间换时间的操作方式，将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代。通过对不同的代设置不同的阈值，可以在不同的时间间隔处理这些对象。

**Q：python为什么慢？**
1. python有一个全局解释器锁。现代计算机搭载拥有多个内核的CPU，一个进程可以分为多个线程并行计算。但是对于python来说，由于GIL锁的存在，限制一次只有一个线程使用python解释器，其他线程要等该线程运行完后其他线程才能运行。所以对于CPU 密集型的任务，Python 的多线程效率提升空间较小。
2. python是一个解释型的语言。像C/C++这些语言直接编译成机器码运行，而Python 的运行过程是虚拟机读入代码，编译成中间代码，解释器再将中间代码翻译成 CPU 可以理解的指令，相比于直接编译成机器码，肯定是慢的。
3. python的变量是动态类型，检查类型和改变类型开销太大。


# References
1. [python110道面试题](https://www.cnblogs.com/lmx123/p/9230589.html)
2. [Python: 什么是*args和**kwargs](https://www.cnblogs.com/yx12138/p/10742766.html)
3. [Python 中的__new__和__init__的区别](https://www.cnblogs.com/shenxiaolin/p/9307496.html)
4. [Python中的垃圾回收机制](https://foofish.net/python-gc.html)
5. [Python 为什么这么慢？](https://blog.csdn.net/chinesehuazhou2/article/details/90746215)
